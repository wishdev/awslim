package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"reflect"
	"strings"
	"text/template"
)

//go:generate go run ../awslim-gen-gen/main.go
//go:generate go get ./...

const serviceTemplateStr = `// Code generated by cmd/awslim-gen/main.go; DO NOT EDIT.
package sdkclient

import (
	"context"

	"github.com/aws/aws-sdk-go-v2/service/{{ .PkgName }}"
)

{{ range .Methods }}
func {{ $.PkgName }}_{{ .Name }}(ctx context.Context, p *clientMethodParam) (any, error) {
	svc := {{ $.PkgName }}.NewFromConfig(p.awsCfg)
	var in {{ .Input }}
	{{- if .InputReaderLengthField }}
	if err := p.Inject("{{ .InputReaderLengthField }}", p.InputReaderLength); err != nil {
		return nil, err
	}
	{{- end }}
	if err := UnmarshalJSON(p.InputBytes, &in, p.Strict); err != nil {
		return nil, err
	}
	if err := p.Validate("{{ $.PkgName }}.{{ .Name }}", "{{ .InputReaderField }}", "{{ .OutputReadCloserField }}"); err != nil {
		return nil, err
	}
	if p.DryRun {
		return nil, ErrDryRun
	}
	{{- if .InputReaderField }}
	if p.InputReader != nil {
		in.{{ .InputReaderField }} = p.InputReader
	}
	{{- end }}
	{{- if .OutputReadCloserField }}
	if out, err := svc.{{ .Name }}(ctx, &in); err != nil {
		return nil, err
	} else {
		if err := p.Output(out.{{ .OutputReadCloserField }}); err != nil {
			return nil, err
		}
		return out, nil
	}
	{{- else }}
	return svc.{{ .Name }}(ctx, &in)
	{{- end }}
}

{{ end }}

var {{ .PkgName }}Methods = map[string]ClientMethod{
{{- range .Methods }}
	"{{ .Name | lower }}": {{ $.PkgName }}_{{ .Name }},
{{- end }}
}
var {{ .PkgName }}OfficialMethodNames = map[string]string{
{{- range .Methods }}
	"{{ .Name | lower }}": "{{ .Name }}",
{{- end }}
}
`

var mainTemplateStr = `// Code generated by cmd/awslim-gen/main.go; DO NOT EDIT.
package sdkclient

func init() {
	clientMethods = map[string]map[string]ClientMethod{
		{{- range . }}
		"{{ . }}": {{ . }}Methods,
		{{- end }}
	}

	clientOfficialMethodNames = map[string]map[string]string{
		{{- range . }}
		"{{ . }}": {{ . }}OfficialMethodNames,
		{{- end }}
	}
}
`

var generatedServices []string

func main() {
	generateAll()
	generateMain()
}

func generateMain() {
	if err := writeTemplate(mainTemplateStr, generatedServices, "main"); err != nil {
		log.Fatal(err)
	}
}

func gen(pkgName string, clientType reflect.Type, genNames []string) error {
	log.Printf("generating %s_gen.go", pkgName)
	generatedServices = append(generatedServices, pkgName)

	methods := make([]map[string]string, 0)
	for i := 0; i < clientType.NumMethod(); i++ {
		method := clientType.Method(i)
		if len(genNames) > 0 && !contains(genNames, method.Name) {
			continue
		}
		params := make([]string, 0)
		for j := 0; j < method.Type.NumIn(); j++ {
			params = append(params, method.Type.In(j).String())
		}
		if len(params) <= 1 {
			log.Printf("no params func %s", method.Name)
			continue
		}
		inputParam := method.Type.In(2)
		var inputReaderField, inputReaderLengthField string
		for j := 0; j < inputParam.Elem().NumField(); j++ {
			field := inputParam.Elem().Field(j)
			// detect io.Reader field refs https://github.com/fujiwara/awslim/pull/6 @mattn
			if t := field.Type.String(); t == "io.Reader" {
				log.Printf("found %s field in %s.%sInput %s %s", t, pkgName, method.Name, field.Name, t)
				if inputReaderField != "" {
					return fmt.Errorf("found multiple io.Reader fields in %s.%sInput", pkgName, method.Name)
				}
				inputReaderField = field.Name
			}
		}
		if inputReaderField != "" {
			for j := 0; j < inputParam.Elem().NumField(); j++ {
				field := inputParam.Elem().Field(j)
				if t := field.Name; strings.Contains(t, "Length") {
					log.Printf("found %s field in %s.%sInput %s %s", t, pkgName, method.Name, field.Name, t)
					if inputReaderLengthField != "" {
						return fmt.Errorf("found multiple Length fields in %s.%sInput", pkgName, method.Name)
					}
					inputReaderLengthField = field.Name
				}
			}
		}

		var outputReadCloserField string
		output := method.Type.Out(0).Elem()
		for j := 0; j < output.NumField(); j++ {
			field := output.Field(j)
			if t := field.Type.String(); t == "io.ReadCloser" {
				log.Printf("found %s field in %s.%sOutput %s %s", t, pkgName, method.Name, field.Name, t)
				if outputReadCloserField != "" {
					return fmt.Errorf("found multiple io.ReadCloser fields in %s.%sOutput", pkgName, method.Name)
				}
				outputReadCloserField = field.Name
			}
		}
		methods = append(methods, map[string]string{
			"Name":                   method.Name,
			"Input":                  strings.TrimPrefix(params[2], "*"),
			"InputReaderField":       inputReaderField,
			"InputReaderLengthField": inputReaderLengthField,
			"OutputReadCloserField":  outputReadCloserField,
		})
	}
	data := map[string]interface{}{
		"PkgName": pkgName,
		"Methods": methods,
	}
	return writeTemplate(serviceTemplateStr, data, pkgName)
}

func contains(ss []string, s string) bool {
	for _, v := range ss {
		if v == s {
			return true
		}
	}
	return false
}

func writeTemplate(t string, v any, name string) error {
	funcs := template.FuncMap{
		"lower": strings.ToLower,
	}
	filename := name + "_gen.go"
	log.Printf("generating %s", filename)
	tmpl, err := template.New("clientGen").Funcs(funcs).Parse(t)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, v); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}
	if err := os.WriteFile(filename, buf.Bytes(), 0644); err != nil {
		return err
	}
	log.Printf("generated %s", filename)
	return nil
}
